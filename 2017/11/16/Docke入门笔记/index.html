<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="一、docker 是什么其实从很早就开始注意到docker这么一个东西的，学习它陆陆续续踩了不少坑，当初为什么会被他吸引呢？其实很简单，就是被它的速度给惊艳到了，在那个虚拟机大行其道的年代，装好一套环境需要几个小时甚至更久，看见docker是有一种多么的不可思议，从此就走上采坑之旅。Docker是一" />
  

  
  
  
  
  
  
  <title>Docke入门笔记 | Coding使我快乐</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一、docker 是什么其实从很早就开始注意到docker这么一个东西的，学习它陆陆续续踩了不少坑，当初为什么会被他吸引呢？其实很简单，就是被它的速度给惊艳到了，在那个虚拟机大行其道的年代，装好一套环境需要几个小时甚至更久，看见docker是有一种多么的不可思议，从此就走上采坑之旅。Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在自己机器上编译">
<meta name="keywords" content="docker">
<meta property="og:type" content="article">
<meta property="og:title" content="Docke入门笔记">
<meta property="og:url" content="https://lozz.cc/2017/11/16/Docke入门笔记/index.html">
<meta property="og:site_name" content="Coding使我快乐">
<meta property="og:description" content="一、docker 是什么其实从很早就开始注意到docker这么一个东西的，学习它陆陆续续踩了不少坑，当初为什么会被他吸引呢？其实很简单，就是被它的速度给惊艳到了，在那个虚拟机大行其道的年代，装好一套环境需要几个小时甚至更久，看见docker是有一种多么的不可思议，从此就走上采坑之旅。Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在自己机器上编译">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://lozz.cc/2017/11/16/Docke入门笔记/docker.png">
<meta property="og:image" content="https://lozz.cc/2017/11/16/Docke入门笔记/docker_settings.png">
<meta property="og:updated_time" content="2018-06-05T08:01:32.064Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Docke入门笔记">
<meta name="twitter:description" content="一、docker 是什么其实从很早就开始注意到docker这么一个东西的，学习它陆陆续续踩了不少坑，当初为什么会被他吸引呢？其实很简单，就是被它的速度给惊艳到了，在那个虚拟机大行其道的年代，装好一套环境需要几个小时甚至更久，看见docker是有一种多么的不可思议，从此就走上采坑之旅。Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在自己机器上编译">
<meta name="twitter:image" content="https://lozz.cc/2017/11/16/Docke入门笔记/docker.png">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
  </script>
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="Coding使我快乐" rel="home">Coding使我快乐</a>
      </h1>
      
        <script type="text/javascript" src="https://v1.hitokoto.cn/?c=f&encode=js&select=%23hitokoto" defer></script>
        <h2 id="hitokoto" class="site-description"></h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/lipstick">lipstick</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-Docke入门笔记" class="post-Docke入门笔记 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title article-title">
      Docke入门笔记
    </h1>
  

        
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="一、docker-是什么"><a href="#一、docker-是什么" class="headerlink" title="一、docker 是什么"></a>一、docker 是什么</h3><p>其实从很早就开始注意到docker这么一个东西的，学习它陆陆续续踩了不少坑，当初为什么会被他吸引呢？其实很简单，就是被它的速度给惊艳到了，在那个虚拟机大行其道的年代，装好一套环境需要几个小时甚至更久，看见docker是有一种多么的不可思议，从此就走上采坑之旅。<br>Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在自己机器上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。这是docker的百度百科定义，看完这个好像并不能说明docker有什么用，没关系，对比一下就知道了，首先说明，这篇文章不会涉及很深奥的内容，旨在用通俗易懂的话语来阐述docke的优点及其基础用法。我们都用过虚拟机吧，第一映像肯定是笨重，启动慢，当然功能上是完全无可挑剔的，但这还不够，于是docker横空出世，还有什么语言能比图片更能说明一切呢？</p>
<p><img src="/2017/11/16/Docke入门笔记/docker.png" alt="docker"></p>
<p>上面这张图就很好的说明一切了，传统的虚拟机是通过软件把计算机的一个个硬件给模拟出来，之后再在模拟出的计算机中安装系统，之后再在系统内部跑应用，就比如需要两个应用，一个跑Nginx一个跑MySQL，那么用虚拟机的话就要安装两次系统，宿主机也就是真实的非虚拟出来的计算机要保存这两个虚拟的系统，占用空间不说最主要的是给宿主机额外的开销，这两个虚拟机的系统都是需要cpu和内存资源的，再来看看docke，可看到的是它只在宿主机内安装个Docker Engine就支持隔离多个应用，注意还是环境隔离的哦，少了两个OS无疑是节约了巨大的资源，这两个应用给我们的感觉就是跑在两个不同的系统中一样，两者通信还要借助特定网络通信，但他们其实是共用的宿主机的系统，至于他们是怎么做到隔离的这又是一个高深的话题了，看到docker有这么多的优点是不是迫不及待的想要试一试了？</p>
<h3 id="二、docker安装及基本配置"><a href="#二、docker安装及基本配置" class="headerlink" title="二、docker安装及基本配置"></a>二、docker安装及基本配置</h3><p>在win7中安装是要通过虚拟机来安装的，在win10中就方便多了，有<a href="https://www.docker.com/docker-windows" target="_blank" rel="external">Docker for Windows</a>安装包，linux下下载对应源码编译安装即可，因为平时开发都是在win10上开发，故在这就简单说一下win10安装Docker for Windows后的配置吧，注意在win10中安装docker for window需要有 Hyper-V 支持，不支持这个的也只能是安装虚拟机来体验docker了，安装完后进入设置界面：</p>
<p><img src="/2017/11/16/Docke入门笔记/docker_settings.png" alt="docker_settings"></p>
<p>给需要共享的磁盘勾选，只有勾选了这个，容器才能访问宿主机的文件，设置这个是需要管理员密码的，没设密码的需要去设置管理员密码，不然不能配置成功，接着就是配置镜像加速了，docker容器是依赖镜像（在docker里面是image）创建的，镜像是从远程拉取的，就跟我们从github上拉取代码一样的，众所周知国内的网路想要拉取一个镜像是多么的不容易，所以就需要配置镜像加速，在Daemon那一栏的Registry mirrors 中填上加速地址就行了，我习惯是使用阿里云的 ‘ <a href="https://otsyn80i.mirror.aliyuncs.com" target="_blank" rel="external">https://otsyn80i.mirror.aliyuncs.com</a> ‘ 加速地址，一切都ok了之后就可以开始了我们喜欢的命令行敲命令了！</p>
<h3 id="三、docker基本操作"><a href="#三、docker基本操作" class="headerlink" title="三、docker基本操作"></a>三、docker基本操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span>docker --version  #查看版本</span><br><span class="line">  Docker version 17.09.0-ce, build afdb6d4</span><br></pre></td></tr></table></figure>
<p>搜索一个image并且拉取下来<br>下载镜像的命令非常简单，使用docker pull命令即可。在docker的镜像网站上面，镜像都是按照”用户名/镜像名”的方式来存储的。<br>可以使用docker images查看拉取下来的镜像,其中IMAGE ID就是镜像id，删除镜像时可以使用这个IMAGE ID删除 docker rmi [IMAGE ID,REPOSITORY]<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span>docker search centos</span><br><span class="line">  NAME            DESCRIPTION                      STARS         OFFICIAL      AUTOMATED</span><br><span class="line">  centos          The official build of CentOS.    3824          [OK]</span><br><span class="line">                                    ...</span><br><span class="line"><span class="meta">-&gt;</span>docker pull learn/tutorial #拉取镜像</span><br><span class="line"><span class="meta">-&gt;</span>docker images</span><br><span class="line">  REPOSITORY          TAG        IMAGE ID        CREATED       SIZE</span><br><span class="line">  centos              latest     a7876479f1aa    4 years ago   128MB</span><br><span class="line"><span class="meta">-&gt;</span>docker rmi a7876479f1aa #删除image</span><br></pre></td></tr></table></figure></p>
<p>在docker容器中运行hello world,使用docker run创建一个容器，docker run之后就会产生一个容器并且保存起来，之后要运行就可以做直接运行容器而不用从新创建容器，这里的容器就是 container,docker的容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。<br>可以通过 docker ps 查看正在运行的容器，当我们运行docker run centos echo “hello word”后看到输出 “hello word” 后再运行 docker ps 时没有任何容器输出出来，这是因为容器在运行完 echo “hello word” 后没有运行任何进程，所以容器就退出了。通过 docker ps -a 可以查看到所有的 container<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span>docker run centos echo "hello word" #通过 centos 镜像创建一个容器来输出 "hello word"</span><br><span class="line">  hello word</span><br><span class="line"><span class="meta">-&gt;</span>docker ps -a</span><br><span class="line">  CONTAINER ID   IMAGE      COMMAND              CREATED          STATUS              PORTS     NAMES</span><br><span class="line">  e46ec634bbe1   centos     "echo 'hello word'"  12 minutes ago   Exited (0) 12 minutes ago</span><br></pre></td></tr></table></figure></p>
<p>接下来就是给容器安装一个简单的程序。之前下载的是centos镜像，所以可以使用 yum 命令来安装程序。<br>备注：yum 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失。但是从 image 重新 run 一个容器出来，之前安装的程序并不存在，因为所有的修改都是针对容器 (container) 的，并不针对 image，所以从 image run 出来的容器都是一个全新的<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span>docker run centos yum -y install net-tools</span><br><span class="line"><span class="meta">-&gt;</span>docker ps -a  #可以看到已经存在两个 container</span><br><span class="line">  CONTAINER ID  IMAGE     COMMAND                CREATED         STATUS           PORTS     NAMES</span><br><span class="line">  2f1bbd6c30e3  centos    "yum install -y ne..." 1 minutes ago   Exited (0) 1 minute ago    competent</span><br><span class="line">  35129633c933  centos    "echo hello word"      1 minutes ago   Exited (0) 1 minute ago    dazzling</span><br></pre></td></tr></table></figure></p>
<p>现在容器是有了，需要的程序也安装好了，但就是只有一个容器，不能运行又有什么用，别急下面就来看看运行容器，但运行容器也有几种方法，一种就是在创建容器的时候并运行，之前说过，容器要保持运行就需要一个活动的进程，当容器内所有的进程都退出了，那么容器也就相应的停止了，所以要创建容器并保持运行容器的话很简单，用ping命令就可以了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span>docker run centos ping lozz.cc</span><br><span class="line">  PING lorencoll.coding.me (103.218.240.147) 56(84) bytes of data.</span><br><span class="line">  64 bytes from 103.218.240.147 (103.218.240.147): icmp_seq=1 ttl=37 time=16.0 ms</span><br><span class="line">  64 bytes from 103.218.240.147 (103.218.240.147): icmp_seq=2 ttl=37 time=16.4 ms</span><br><span class="line">  Ctrl+C</span><br><span class="line"><span class="meta">-&gt;</span>docker ps  #查看活动的容器</span><br><span class="line">  CONTAINER ID    IMAGE      COMMAND        CREATED              STATUS       PORTS        NAMES</span><br><span class="line">  10c5c2754279     centos    "ping lozz.cc" About a minute ago   Up About a minute         jolly</span><br></pre></td></tr></table></figure></p>
<p>有启动就会有停止，停止可以用 docker stop container_id 命令来停止某个容器，好了现在开始讲第二种启动容器的方法，这种方法是在容器已经被创建的情况下使用的，我们知道每次 run 都是创建出一个新的容器，有的时候不需要创建，可以使用 docker start  container_id 来启动一个容器，这时就需要注意了，启动后的容器没活动的进程容器依然是会退出的，因为容器是从镜像创建而来的，所以容器也是包含了创建这个容器的附加命令的，在 docker start 的时候又会从新执行一遍创建这个容器的附件命令，有点绕口是不是，敲一遍就知道了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span>docker ps    #查看活动的容器</span><br><span class="line">  CONTAINER ID    IMAGE    COMMAND          CREATED          STATUS      PORTS         NAMES</span><br><span class="line">  10c5c2754279    centos   "ping lozz.cc"   23 minutes ago   Up 23 minutes             jolly</span><br><span class="line"></span><br><span class="line"><span class="meta">-&gt;</span>docker ps -a #查看所有存在的容器</span><br><span class="line">  CONTAINER ID    IMAGE    COMMAND                CREATED          STATUS      PORTS        NAMES</span><br><span class="line">  10c5c2754279    centos   "ping lozz.cc"         21 minutes ago   Up 21 minutes            jolly</span><br><span class="line">  2f1bbd6c30e3    centos   "yum install -y ne..." 36 minutes ago   Exited (0) 3 minute ago  competent</span><br><span class="line">  35129633c933    centos   "echo hello word"      About hour ago   Exited (0) hour ago      dazzling</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 尝试启动安装了 net-tools 的容器，</span><br><span class="line"><span class="meta">#</span> -i 的意思是把信息输出到控制台中，没有这个参数执行后就直接返回一个CONTAINER ID</span><br><span class="line"><span class="meta">-&gt;</span>docker start -i 2f1bbd6c30e3</span><br><span class="line">  Loaded plugins: fastestmirror, ovl</span><br><span class="line">  Loading mirror speeds from cached hostfile</span><br><span class="line">   * base: mirrors.aliyun.com</span><br><span class="line">   * extras: mirrors.aliyun.com</span><br><span class="line">   * updates: mirrors.cn99.com</span><br><span class="line">  Package net-tools-2.0-0.22.20131004git.el7.x86_64 already installed and latest version</span><br><span class="line">  Nothing to do</span><br><span class="line"><span class="meta">-&gt;</span>docker ps  #查看活动的容器</span><br><span class="line">  CONTAINER ID    IMAGE    COMMAND          CREATED          STATUS      PORTS         NAMES</span><br><span class="line">  10c5c2754279    centos   "ping lozz.cc"   30 minutes ago   Up 30 minutes             jolly</span><br><span class="line"><span class="meta">-&gt;</span>docker stop 10c5c2754279  #停止执行ping命令的容器</span><br><span class="line">  10c5c2754279</span><br><span class="line"><span class="meta">-&gt;</span>docker start -i 10c5c2754279  #启动执行ping命令的容器</span><br><span class="line">  PING lorencoll.coding.me (103.72.144.62) 56(84) bytes of data.</span><br><span class="line">  64 bytes from 103.72.144.62 (103.72.144.62): icmp_seq=1 ttl=37 time=15.1 ms</span><br><span class="line">  64 bytes from 103.72.144.62 (103.72.144.62): icmp_seq=2 ttl=37 time=16.3 ms</span><br><span class="line">  64 bytes from 103.72.144.62 (103.72.144.62): icmp_seq=3 ttl=37 time=16.8 ms</span><br><span class="line">  Ctrl+C</span><br></pre></td></tr></table></figure></p>
<p>从上面的提示就可以知道，这个 start 命令把之前创建命令 docker run centos yum -y install net-tools 中的 yum -y install net-tools 也执行了一遍，因为这个容器已经安装过了 net-tools ，所以 yum 才提示不需要安装，查看活动的容器中还是只有之前的容器在运行。那么现在有一个问题，我安装 net-tools 的那个容器不能用了吗，其实不然，这个容器之所以“不能用”只是因为创建的时候没有指定合适的命令，要用它也是可以的，我们把他从新打包成一个 image 也就是镜像，打包好了后再通过它生成容器就可以了，实际上这也符合 Docker 的应用隔离思想，把容器打包成镜像的命令很简单 docker commit container_id image_name，我的打包命令是 docker commit 2f1bbd6c30e3 lorenwe/centos_net_tools，这个命名是有规矩的，前面是 docker 的用户id，如果想要把这个镜像推送到 docker hub 这个名字就不能随便命名了，如果不推送到 docker hub 就无所谓了，但也不能太随便对不对。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span>docker ps -a</span><br><span class="line">  CONTAINER ID    IMAGE    COMMAND                CREATED        STATUS     PORTS     NAMES</span><br><span class="line">  10c5c2754279    centos   "ping lozz.cc"         About an hour ago                   jolly</span><br><span class="line">  2f1bbd6c30e3    centos   "yum install -y ne..." About an hour ago                   competent</span><br><span class="line">  35129633c933    centos   "echo hello word"      About an hour ago                   dazzling</span><br><span class="line"><span class="meta">-&gt;</span>docker commit 2f1bbd6c30e3 lorenwe/centos_net_tools</span><br><span class="line">  sha256:35f8073cede14473601d9f138a9815bc9ab5c7d97f914ca2f5ce910bd78b5750</span><br><span class="line"><span class="meta">-&gt;</span>docker images</span><br><span class="line">  REPOSITORY                  TAG          IMAGE ID         CREATED             SIZE</span><br><span class="line">  lorenwe/centos_net_tools    latest       35f8073cede1     23 seconds ago      277MB</span><br><span class="line">  centos                      latest       d123f4e55e12     2 weeks ago         197MB</span><br><span class="line">  d4w/nsenter                 latest       9e4f13a0901e     14 months ago       83.8kB</span><br></pre></td></tr></table></figure></p>
<p>就这么简单，一个新的镜像(image)就创建好了，现在可以通过这个镜像来做些有趣的事情了，依然是 docker run 命令，只不过这次多增加一些参数，如 docker run -itd –name my_net_tools lorenwe/centos_net_tools /bin/bash<br>其中参数 itd 分别是表示 ‘标准输入给容器’，‘分配一个虚拟终端’，‘以守护进程方式运行（后台）’， –name 自然是指定创建后容器的名称了，/bin/bash 执行bash脚本，执行以上命令，就能创建一个后台运行的容器了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span>docker run -itd --name my_net_tools lorenwe/centos_net_tools /bin/bash</span><br><span class="line">  e1d843f7726f67d2635042695e2065b383736a341edd2e83753be9fabec03de0</span><br><span class="line"><span class="meta">-&gt;</span>docker ps  #查看活动的容器</span><br><span class="line">  CONTAINER ID   IMAGE                     COMMAND      CREATED      STATUS   PORTS      NAMES</span><br><span class="line">  e1d843f7726f   lorenwe/centos_net_tools  "/bin/bash"  7 seconds ago                    my_net_tools</span><br><span class="line">  10c5c2754279   centos                    "ping lozz.cc"            Up 25 minutes       jolly</span><br></pre></td></tr></table></figure></p>
<p>嗯，运行了，然后呢，当然是可以进入容器中玩玩呀，使用 docker attach container_id 进入Docker容器<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span>docker attach e1d843f7726f</span><br><span class="line">[root@e1d843f7726f /]# ip addr</span><br><span class="line">bash: ip: command not found</span><br><span class="line">[root@e1d843f7726f /]# ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.3  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 40  bytes 1900 (1.8 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        loop  txqueuelen 1  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">[root@e1d843f7726f /]#</span><br></pre></td></tr></table></figure></p>
<p>这个因为这个容器是基于 centos 来的，而 docker 的基础 centos 镜像都是精简版的，故很多命令没有，比如这个 ip addr ，这也是之前选择安装 net-tools 的原因，因为安装了这个就可以使用 ifconfig 来查看网卡配置。至此，是不是对 docker 有了一个基本的了解了呢，是不是突然来了一个灵感，比如想要搭建一个 Nginx 静态服务器，步骤就是 pull 一个基础镜像下来，通过这个基础镜像 run 出一个容器后再容器内安装上 Nginx 之后再从新打包成一个新的镜像就可以了。实际上使用 docke 构建镜像不会那样去做，步骤繁琐不说，还不是很灵活，毕竟之前构建的 lorenwe/centos_net_tools 镜像也有277MB呢！分发起来不太方便，于是 Dockerfile 出现了，其作用就是通过特定的格式把一个镜像描述出来，通过 docker 来构建出这个镜像，描述的流程其实和之前的手动构建的流程差不多，通过同一个 Dockerfile 可以构建出一模一样的环境，这也是 docke 常用于工作中统一系统运行环境的原因。</p>
<h3 id="四、把-docker-推送到-docker-hub"><a href="#四、把-docker-推送到-docker-hub" class="headerlink" title="四、把 docker 推送到 docker hub"></a>四、把 docker 推送到 docker hub</h3><p>推送镜像的命令很简单，只需要 docker push image_name 就可以了，在把镜像推送到 docker hub 之前还是有一些准备工作要做的，需要先去 docker hub 注册一个账号，之后再在 docker 中登入这个账号就可以推送镜像了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span>docker login  #登入到 docker hub</span><br><span class="line">  Login with your Docker ID to push and pull images from Docker Hub. </span><br><span class="line">  If you don't have a Docker ID, head over to https://hub.docker.com to create one.</span><br><span class="line">  Username (lorenwe): lorenwe</span><br><span class="line">  Password:</span><br><span class="line">  Login Succeeded</span><br><span class="line"><span class="meta">  #</span> 现在就可推送镜像到 docker hub</span><br><span class="line"><span class="meta">-&gt;</span>docker images</span><br><span class="line">  REPOSITORY                TAG        IMAGE ID            CREATED             SIZE</span><br><span class="line">  lorenwe/centos_net_tools  latest     35f8073cede1        About an hour ago   277MB</span><br><span class="line">  centos                    latest     d123f4e55e12        2 weeks ago         197MB</span><br><span class="line">  d4w/nsenter               latest     9e4f13a0901e        14 months ago       83.8kB</span><br><span class="line"><span class="meta">-&gt;</span>docker push lorenwe/centos_net_tools</span><br><span class="line">  The push refers to a repository [docker.io/lorenwe/centos_net_tools]</span><br><span class="line">  d0ba94ecc37e: Pushed</span><br><span class="line">  cf516324493c: Mounted from library/centos</span><br><span class="line">  latest: digest: sha256:276814315437cf5d416ed4b5713fe10c914beaea96bcf583b786a6778c80830f size: 741</span><br></pre></td></tr></table></figure></p>
<p>由于墙和 docker hub 的服务器离天朝远的原因推送会很慢，成功后就能在 docker hub 的个人中心看到自己推送的镜像了，以后想要在使用这个镜像就可以直接 docker pull 就行了，也可以把镜像推送到国内的容器镜像服务平台，比如我用的是阿里云的容器Hub，可能是因为速度快吧所以用着舒服了，唯一不好的就是那又臭又长的镜像名称有点难受。</p>
<h3 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h3><p>docker 基础到这一步已经是介绍的差不多了，写这篇文章的目的就是用通俗易懂的语言及示例来讲明 docker 镜像与容器之间的关系，限于篇幅 docker 还有很多功能没有介绍，日后有时间再来做后续的文章，例如 Dockerfile，docker 卷的共享和网络通信等等都是一些特别有意思的功能，模拟构建一个可移植的分布式的开发平台已经不是梦了。处女作，各位轻喷！</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2017/11/16/Docke入门笔记/">
    <time datetime="2017-11-16T07:23:51.000Z" class="entry-date">
        2017-11-16
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/">docker</a></li></ul>

    <span id="busuanzi_container_page_pv">
      本文总阅读量<span id="busuanzi_value_page_pv"></span>次
    </span>
    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
        <span class="nav-previous"><a href="/2018/05/16/Dockerfile编写规则/" rel="prev"><span class="meta-nav">←</span> Dockerfile编写规则</a></span>
    
    
        <span class="nav-next"><a href="/2017/11/15/PHP中的匿名函数和闭包/" rel="next">PHP中的匿名函数和闭包 <span class="meta-nav">→</span></a></span>
    
</nav><!-- .nav-single -->







</div></div>
        <!-- <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2018/05/16/Dockerfile编写规则/">Dockerfile编写规则</a>
          </li>
        
          <li>
            <a href="/2017/11/16/Docke入门笔记/">Docke入门笔记</a>
          </li>
        
          <li>
            <a href="/2017/11/15/PHP中的匿名函数和闭包/">PHP中的匿名函数和闭包</a>
          </li>
        
          <li>
            <a href="/2017/11/14/composer笔记/">composer 笔记</a>
          </li>
        
          <li>
            <a href="/2017/11/12/PHP调试必经之路xdebug/">PHP调试必经之路xdebug</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-content">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/">PHP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP-Debug/">PHP,Debug</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/composer/">composer</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-content tagcloud">
      <a href="/tags/PHP/" style="font-size: 10px;">PHP</a> <a href="/tags/PHP-Debug/" style="font-size: 10px;">PHP,Debug</a> <a href="/tags/composer/" style="font-size: 10px;">composer</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a>
    </div>
  </aside>

  
</div> -->
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2018 Loren
    All rights reserved.</p>
    <p>Hosted by &mdash; <a href="https://pages.coding.me" target="_blank">Coding Pages</a></p>
    <p>
        <span id="busuanzi_container_site_uv" style='display:none'>
            本站总访问量<span id="busuanzi_value_site_uv"></span>次
        </span>
    </p>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>